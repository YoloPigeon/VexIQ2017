#pragma config(Sensor, port3,  armGyro,        sensorVexIQ_Gyro)
#pragma config(Motor,  motor4,         elevMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Sensor, port5,  distRight,      sensorVexIQ_Distance)
#pragma config(Sensor, port6,  distLeft,       sensorVexIQ_Distance)
#pragma config(Sensor, port8,  colorCenter,    sensorVexIQ_ColorHue)
#pragma config(Sensor, port9,  colorRight,     sensorVexIQ_ColorHue)
#pragma config(Sensor, port10, bumpSwitch,     sensorVexIQ_Touch)
#pragma config(Motor,  motor2,          armMotor,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor7,          leftMotor,     tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor12,         rightMotor,    tmotorVexIQ, PIDControl, driveRight, encoder)


//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#ifdef TEST
/*
Button Handler Code
*/
typedef void ButtonCallback(void);

struct ButtonInfo
{
	bool bButtonDown;
	void *ButtonDown;
	void *ButtonUp;
	void *ButtonPressed;
};


ButtonInfo ButtonHandlerArray[kNumbOfVexRFIndices];

task ButtonHandler()
{
	memset(ButtonHandlerArray,0,sizeof(ButtonHandlerArray));
		repeat (forever) {
			int count;
			for(count=0;count < kNumbOfVexRFIndices;count++)
			{
					if(vexRT[count] == 1 && !ButtonHandlerArray[count].bButtonDown)
					{
						ButtonHandlerArray[count].bButtonDown = true;
						if(ButtonHandlerArray[count].ButtonDown)
							ButtonHandlerArray[count].ButtonDown();
						if(ButtonHandlerArray[count].ButtonPressed)
							ButtonHandlerArray[count].ButtonPressed();
				  }
				  else if(vexRT[count] == 0 && ButtonHandlerArray[count].bButtonDown)
				  {
						ButtonHandlerArray[count].bButtonDown = false;
						if(ButtonHandlerArray[count].ButtonUp)
							ButtonHandlerArray[count].ButtonUp();
				  }
		  }
		}
}

bool SetButtonHandlerCallback(int button,void *ButtonDown,void *ButtonUp,void *ButtonPressed)
{
	bool bRet = false;
	if(button < kNumbOfVexRFIndices)
	{
		ButtonHandlerArray[button].ButtonDown = ButtonDown;
		ButtonHandlerArray[button].ButtonUp = ButtonUp;
		ButtonHandlerArray[button].ButtonPressed = ButtonPressed;
		bRet = true;
	}
	return bRet;
}

#endif
#define DRIVER
#ifdef DRIVER
/*extern bool bPopulatedMotorDriveSides;*/
/*
End Button Handler Code
*/
bool bArcadeControl = true;
long GyroStartPos = 0;
bool bReverseDirection=false;

/*
void ResetArm()
{
	while(abs(GyroStartPos - getGyroDegrees(armGyro)) > 5)
	{
		if(GyroStartPos - getGyroDegrees(armGyro) < 10)
			moveMotorTarget(armMotor, GyroStartPos - getGyroDegrees(armGyro), 50);
		else
			moveMotorTarget(armMotor, 10, 50);
   }
}
*/
task CheckButtons()
{
	bool bButtonDown[kNumbOfVexRFIndices];


	displayText(line5, "forward");
	bButtonDown[BtnFUp] = false;
	bButtonDown[BtnFDown] = false;

	repeat (forever) {
		/*BtnFUp Handling*/
  	if( vexRT[ BtnFUp ] == 1 && bArcadeControl && !bButtonDown[BtnFUp])
		{
			bButtonDown[BtnFUp] = true;
			bArcadeControl = false;
			displayText(line4, "tank");
			playSound(soundCarAlarm4);
		}
		else if( vexRT[ BtnFUp ] == 1 && !bArcadeControl && !bButtonDown[BtnFUp])
		{
			bButtonDown[BtnFUp] = true;
			bArcadeControl = true;
			displayText(line4, "arcade");
			playSound(soundSiren4);
   	}
   	if( vexRT[ BtnFUp ] == 0)
   		bButtonDown[BtnFUp] = false;

   	/*	BtnRUp*/

  	if( vexRT[ BtnRUp ] == 1 && !bButtonDown[BtnRUp])
		{
			bButtonDown[BtnRUp] = true;
			playSound(soundSiren4);
			setMotor(elevMotor,100);
		}
   	if( vexRT[ BtnRUp ] == 0 && bButtonDown[BtnRUp])
   	{
   		stopMotor(elevMotor);
   		playSound(soundSiren4);
   		bButtonDown[BtnRUp] = false;
    }
   	/*	BtnRDown*/

  	if( vexRT[ BtnRDown ] == 1 && !bButtonDown[BtnRDown])
		{
			bButtonDown[BtnRDown] = true;
			setMotor(elevMotor,-100);
   	}
   	if( vexRT[ BtnRDown ] == 0 && bButtonDown[BtnRDown])
   	{
   		stopMotor(elevMotor);
   		bButtonDown[BtnRDown] = false;
   	}

		/*BtnFDown Handling*/
  	if( vexRT[ BtnFDown ] == 1 && !bReverseDirection && !bButtonDown[BtnFDown])
		{
			bButtonDown[BtnFDown] = true;
			bReverseDirection = true;
			displayText(line5, "reverse");
			setMotorReversed(leftMotor, false);
			setMotorReversed(rightMotor, true);
			playSound(soundWrongWay);

		}
		else if( vexRT[ BtnFDown ] == 1 && bReverseDirection && !bButtonDown[BtnFDown])
		{
			bButtonDown[BtnFDown] = true;
			bReverseDirection = false;
			displayText(line5, "forward");
			setMotorReversed(leftMotor, true);
			setMotorReversed(rightMotor, false);
			playSound(soundWrongWays);
   	}
   	if( vexRT[ BtnFDown ] == 0)
   		bButtonDown[BtnFDown] = false;


	  if( vexRT[ BtnEDown ] == 1)
	  {
	  	/*displayText(line3, "override EDown = 1");*/
	  	moveMotorTarget(armMotor, 10, 50);
	  }

	  if( vexRT[ BtnEUp ] == 1)
	  {
	  	/*displayText(line3, "override down");*/
	  	moveMotorTarget(armMotor, -10, 50);
	  }
  }

}
void myArcadeControl(TVexJoysticks verticalJoystick = ChA, TVexJoysticks horizontalJoystick = ChB, short threshold = 10)
{
	short nRightSideSpeed;
	short nLeftSideSpeed;

	updateMotorDriveTrain();

	if(abs(vexRT[verticalJoystick]) <= abs(threshold) && abs(vexRT[horizontalJoystick]) <= abs(threshold))
	{
		nRightSideSpeed = 0;
		nLeftSideSpeed 	= 0;
	}
	else
	{
	 	nRightSideSpeed = ((getJoystickValue(verticalJoystick) - getJoystickValue(horizontalJoystick))/2);
		nLeftSideSpeed = ((getJoystickValue(verticalJoystick) + getJoystickValue(horizontalJoystick))/2);

		if(nGlobalJoyScaledValue != nMaxJoyScaleValue)
		{
			nRightSideSpeed = nRightSideSpeed * (nGlobalJoyScaledValue / 100.0);
			nLeftSideSpeed 	= nLeftSideSpeed * (nGlobalJoyScaledValue / 100.0);
		}
	}
	if(!bReverseDirection)
		setMotorSpeeds(nLeftSideSpeed, nRightSideSpeed);
	else
		setMotorSpeeds(nRightSideSpeed, nLeftSideSpeed);
}

task main()
{
	bool bBumper1Pressed = false;
  bool bMotorOverlimit = false;

 	arcadeControl(ChA, ChB, 0);
 	displayText(line4, "arcade");
 	startTask(CheckButtons);
  GyroStartPos = getGyroDegrees(armGyro);

  /*SetButtonHandlerCallback(BtnRUp,NULL,NULL,RUpPressed);*/
	/*setMotorCurrentLimit(armMotor, 800);*/
	setMotorEncoderUnits(encoderDegrees);
	repeat (forever) {



		string gyroPosition = getGyroDegrees(armGyro);
		displayText(line1,gyroPosition);

		/*displayMotorValues(line1, armMotor);
		displayMotorValues(line2, leftMotor);
		displayMotorValues(line3, rightMotor);*/
	/*	armControl(armMotor, BtnEDown, BtnEUp, 30);*/
		if(bArcadeControl)
			myArcadeControl(ChA, ChB, 0);
	  else
	  	tankControl(ChD,ChA,10);
	 displaySensorValues(line2, bumpSwitch);

	   if(getBumperValue(bumpSwitch) && bBumper1Pressed == false)
	   {
	     setMotorTarget(armMotor, -130, 20);
	     /*setMotorBrakeMode(armMotor, motorCoast);*/

	     bBumper1Pressed = true;
	   }

	   if(!getBumperValue(bumpSwitch) && bBumper1Pressed)
	   {
	     setMotorTarget(armMotor,0, 20);
	   /*  setMotorBrakeMode(armMotor, motorCoast);*/
	     bBumper1Pressed = false;
	     /*resetMotorEncoder(armMotor);*/

	   }
	   if(getMotorZeroVelocity(armMotor))
	   {
	   /*  setMotorBrakeMode(armMotor, motorCoast);*/
	   }
	   if(getMotorCurrent(armMotor) > 600 && !bMotorOverlimit)
	   {
	     bMotorOverlimit = true;
	     clearTimer(T1);
	   }
	   else if(getMotorCurrent(armMotor) > 600 && bMotorOverlimit)
	   {
	     if(time1[T1] > 5000)
	     {
	      /* playSound(soundCarAlarm2);*/
	       /*resetMotorEncoder(armMotor);*/
	      /* moveMotorTarget(armMotor,-10, 20);*/
	       setMotorSpeed(armMotor,0);
	       setMotorBrakeMode(armMotor, motorCoast);
	     }
	   }
	   else
	   {
	   	 bMotorOverlimit = false;
	   }

	   displayTextLine(line5, "%d:%d:%d", getMotorCurrent(armMotor),getMotorBrakeMode(armMotor),getMotorZeroVelocity(armMotor));
	}
}
#else
task main()
{
	repeat (forever) {
		lineTrackLeft(colorRight,90,20,10);
		displaySensorValues(line1, colorRight);

	}

}
#endif
