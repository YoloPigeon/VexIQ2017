#pragma config(Sensor, port1,  bumpSwitch,     sensorVexIQ_Touch)
#pragma config(Sensor, port4,  armGyro,        sensorVexIQ_Gyro)
#pragma config(Sensor, port5,  distRight,      sensorVexIQ_Distance)
#pragma config(Sensor, port6,  distLeft,       sensorVexIQ_Distance)
#pragma config(Sensor, port8,  colorCenter,    sensorVexIQ_ColorHue)
#pragma config(Sensor, port9,  colorRight,     sensorVexIQ_ColorHue)
#pragma config(Motor,  motor2,          armMotor,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor7,          leftMotor,     tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor12,         rightMotor,    tmotorVexIQ, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 * Grid Tracker Begin
 */
 /*Setup*/
#define GRID_WIDTH 2
#define GRID_LENGTH 2
#define GRID_THRESHHOLD_FOLLOWER 90
#define GRID_THRESHHOLD_DETECTOR 120
#define GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER  colorCenter
#define GRID_PORT_COLOR_SENSOR_LINE_DETECTOR  colorRight
#define GRID_PORT_GYRO  armGyro
#define GRID_GYRO_THRESHOLD 2

int GRID_SPEED_PRIMARY = 50;
int GRID_SPEED_SECONDARY = 25;
int GRID_TURN_SPEED_FAST = 30;
int GRID_TURN_SPEED_SLOW = -30;



/*Local variables*/
int GridX = 0;
int GridY = 0;
int TargetX = 1;
int TargetY = 1;
int TargetDir = 0;
bool gridPause=true;

#define GRID_DIR_NORTH 0
#define GRID_DIR_EAST  270
#define GRID_DIR_SOUTH  180
#define GRID_DIR_WEST 90

int GridDirection = GRID_DIR_NORTH;

bool bLineDetected = false;

  int GridGetGyroDegrees()
  {
   /*
  	return getGyroHeading(GRID_PORT_GYRO);
  	*/
  	 int Degrees = getGyroDegrees(GRID_PORT_GYRO);
  	 if(Degrees < 0)
  	 {
  	 	  while(Degrees < 0)
  	 	  	Degrees += 360;
     }
     if(Degrees > 360)
     {
  	 	  while(Degrees > 360)
  	 	  	Degrees -= 360;
     }
     return Degrees;
  }
  void GridUpdateStatus()
  {
		displayTextLine(line1,"%d:%d %d:%d Dir:%d:%d %d",GridX,GridY,TargetX,TargetY,getGyroDegrees(GRID_PORT_GYRO),GridGetGyroDegrees(),TargetDir);
  }
  task Display()
  {
  	 repeat (forever) {
  	   GridUpdateStatus();
  	   sleep(25);
  	 }

  }
  void GridInit()
  {
  	startTask(Display);
  	resetGyro(GRID_PORT_GYRO);
		if(getColorMode(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER) != colorTypeGrayscale_Reflected)
		{
			setColorMode(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER, colorTypeGrayscale_Reflected);
			while(!getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER))
			{
				sleep(25);
			}
		}

		if(getColorMode(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) != colorTypeGrayscale_Reflected)
		{
			setColorMode(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR, colorTypeGrayscale_Reflected);
			while(!getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR))
			{
				sleep(25);
			}
		}
    sleep(1000);
  }


  void GridPause()
  {
     gridPause = true;
  }
  void GridResume()
  {
     gridPause = false;
  }
  void GridGoto(int x,int y)
  {
  	TargetX=x;
  	TargetY=y;
  	GridResume();
  }

  void GridSetDirection(int Direction)
  {
  	updateMotorDriveTrain();
  	TargetDir=Direction;
  	GridUpdateStatus();



  	while(abs(GridGetGyroDegrees()-Direction) > GRID_GYRO_THRESHOLD)
  	{
  		int Distance;
  		if(GridGetGyroDegrees()-Direction < -180)
  		{
  			Distance=(GridGetGyroDegrees()-Direction+180) * -1;
  	  }
  	  else
  	  {
  	  	Distance=GridGetGyroDegrees()-Direction;
  	  }

  	/*	IF(A2-B2 < -180,(A2-B2+180)*-1,A2-B2)*/
			if(Distance > 0 && Distance <= 180)
			{
	    	//Right
				setMotorSpeeds(GRID_TURN_SPEED_FAST,GRID_TURN_SPEED_SLOW);
			}
    	else
    	{
			 	//Left
    	  setMotorSpeeds(GRID_TURN_SPEED_SLOW,GRID_TURN_SPEED_FAST);
      }
      GridUpdateStatus();
    }
    stopAllMotors();
    GridDirection = Direction;
    playSound(soundWrongWay);
    sleep(10000);
  }
		void GridTurnToLine()
	{
		bool bFound = false;
		bool bOnLine = false;
		bool bReverse=false;
		return;
		setMotorSpeeds(10, 10*-1);
		/*Find the right edge, when turning right wait until we cross the whole line*/
		while(!bFound && !bReverse)
		{

			if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) < GRID_THRESHHOLD_DETECTOR)
			{
				bOnLine = true;
			}
			else if(bOnLine)
			{
				bFound = true;
		  }
			if(abs(GridGetGyroDegrees()-GridDirection) > 45)
			{
				bReverse=true;
			}
	  }
	  if(!bFound)
	  {
	  	bReverse=false;
	  	setMotorSpeeds(10 * -1, 10);
			while(!bFound && !bReverse)
			{
				if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) < GRID_THRESHHOLD_DETECTOR)
				{
					bFound = true;
				}
				if(abs(GridGetGyroDegrees()-GridDirection) > 45)
				{
					bReverse=true;
				}
	  	}
	  }
	  stopAllMotors();
  }

	void GridProcess()
	{
	  updateMotorDriveTrain();

	  if((GridX != TargetX || GridY != TargetY) && !gridPause)
	  {
	  	if(GridY != TargetY)
	  	{
	  		if(GridY < TargetY)
	  		{
	  			if(GridDirection != GRID_DIR_NORTH)
	  			{
	  				displayText(line2,"TURN NORTH");
	  				GridSetDirection(GRID_DIR_NORTH);
	  				GridTurnToLine();
	  			}
	  		}
	  	  else
	  	  {
	  	  	if(GridDirection != GRID_DIR_SOUTH)
	  	  	{
	  	  		displayText(line2,"TURN SOUTH");
	  	  		GridSetDirection(GRID_DIR_SOUTH);
	  	  		GridTurnToLine();
	  	  	}
	  	  }
	    }
	    else if(GridX != TargetX)
	    {
	  		if(GridX < TargetX)
	  		{
	  			if(GridDirection != GRID_DIR_EAST)
	  			{
	  				displayText(line2,"TURN EAST");
	  				GridSetDirection(GRID_DIR_EAST);
	  				GridTurnToLine();
	  			}
	  		}
	  	  else
	  	  {
	  	  	if(GridDirection != GRID_DIR_WEST)
	  	  	{
	  	  		displayText(line2,"TURN WEST");
	  	  		GridSetDirection(GRID_DIR_WEST);
	  	  		GridTurnToLine();
	  	  	}
	  	  }
	    }
			if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER) > GRID_THRESHHOLD_FOLLOWER)
				setMotorSpeeds(GRID_SPEED_SECONDARY, GRID_SPEED_PRIMARY);
			else
				setMotorSpeeds(GRID_SPEED_PRIMARY, GRID_SPEED_SECONDARY);

			if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) < GRID_THRESHHOLD_DETECTOR && bLineDetected == false)
			{
				if(GridDirection == GRID_DIR_NORTH)
					GridY++;
			  else if(GridDirection == GRID_DIR_SOUTH)
			  	GridY--;
			  else if(GridDirection == GRID_DIR_EAST)
			  	GridX++;
			  else if(GridDirection == GRID_DIR_WEST)
			  	GridX--;

				bLineDetected = true;
			}
			if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) > GRID_THRESHHOLD_DETECTOR)
			{
				bLineDetected = false;
			}

	  }
	  else
	  {
	  	  /*Reached the target*/
	  	  if(!gridPause)
	  	  {
	 		 		stopAllMotors();
	 		 		GridPause();
	 		  }

	  }


		GridUpdateStatus();
	}
	void GridFindLine(bool bFarSide)
	{
		bool bFound = false;
		setMotorSpeeds(GRID_SPEED_PRIMARY, GRID_SPEED_PRIMARY);
		while(!bFound)
		{
			if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) < GRID_THRESHHOLD_DETECTOR)
			{
				bFound = true;
			}
	  }
	  if(bFarSide)
	  {
	  	bFound=false;
	  	while(!bFound)
	  	{
				if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) < GRID_THRESHHOLD_DETECTOR)
				{
					bFound = true;
				}
		  }
	  }
	  stopAllMotors();
  }

/*
 * Grid Tracker End
 */


 task CheckBumper()
 {
   bool bBumper1Pressed = false;
   bool bMotorOverlimit = false;
   repeat (forever) {
		 if(getBumperValue(bumpSwitch) && bBumper1Pressed == false)
	   {
	     setMotorTarget(armMotor, -130, 20);
	     /*setMotorBrakeMode(armMotor, motorCoast);*/

	     bBumper1Pressed = true;
	   }

	   if(!getBumperValue(bumpSwitch) && bBumper1Pressed)
	   {
	     setMotorTarget(armMotor,0, 20);
	   /*  setMotorBrakeMode(armMotor, motorCoast);*/
	     bBumper1Pressed = false;
	     /*resetMotorEncoder(armMotor);*/

	   }
	   if(getMotorZeroVelocity(armMotor))
	   {
	   /*  setMotorBrakeMode(armMotor, motorCoast);*/
	   }
	   if(getMotorCurrent(armMotor) > 600 && !bMotorOverlimit)
	   {
	     bMotorOverlimit = true;
	     clearTimer(T1);
	   }
	   else if(getMotorCurrent(armMotor) > 600 && bMotorOverlimit)
	   {
	     if(time1[T1] > 5000)
	     {
	      /* playSound(soundCarAlarm2);*/
	       /*resetMotorEncoder(armMotor);*/
	      /* moveMotorTarget(armMotor,-10, 20);*/
	       setMotorSpeed(armMotor,0);
	       setMotorBrakeMode(armMotor, motorCoast);
	     }
	   }
	   else
	   {
	   	 bMotorOverlimit = false;
	   }
   }

}
task main()
{
	GridInit();

	bool done = false;
	int job=1;
	displayText(line5,"job1");

	GridSetDirection(GRID_DIR_EAST);
	sleep(2000);
	GridSetDirection(GRID_DIR_SOUTH);
	sleep(2000);
	GridSetDirection(GRID_DIR_WEST);
	sleep(2000);	done=true;
	GridSetDirection(GRID_DIR_SOUTH);
	sleep(2000);	done=true;
		GridSetDirection(GRID_DIR_EAST);
	sleep(2000);	done=true;
		GridSetDirection(GRID_DIR_NORTH);
		sleep(2000);	done=true;
		GridSetDirection(GRID_DIR_SOUTH);

	sleep(2000);	done=true;
	startTask(CheckBumper);
	while (!done) {

		GridProcess();
		if(gridPause)
		{
			switch(job)
			{
				case 1:
				{
				  displayTextLine(line5,"Job %d",job);
					GridFindLine(true);
					playSound(soundTada);
					sleep(10000);
					GridX = 2;
					GridY = 1;
					TargetX = 2;
					TargetY = 1;
					job++;
			  }
				break;
				case 2:
				{
				  displayTextLine(line5,"Job %d",job);
					GridGoto(0,1);
					/*playSound(soundTada);
					sleep(10000);					*/
					job++;
				}
				break;

				case 3:
				{
					GridSetDirection(GRID_DIR_EAST);
					playSound(soundTada);
					sleep(2000);

					/*displayTextLine(line5,"Job %d",job);
					GridSetDirection(GRID_DIR_NORTH);
					playSound(soundTada);
					sleep(2000);
					GridGoto(1,2);					*/
					while(!done)
					{
						  if(getDistanceValue(distLeft) > 100 && getDistanceValue(distRight) > 100)
						  {
								  updateMotorDriveTrain();
								  if(getDistanceValue(distLeft) > getDistanceValue(distRight))
								  	setMotorSpeeds(-10,0);
								 else
								    setMotorSpeeds(0,-10);
					   }
   					 else
   					 {
     				  	stopAllMotors();
     				  	done=true;
     				 }

     				displayTextLine(line5,"%d:%d:%d:%d ",getDistanceValue(distLeft),getDistanceValue(distRight),getDistanceSecondStrongest(distLeft),getDistanceSecondStrongest(distRight));


   				}
					job++;
					playSound(soundTada);
					sleep(2000);

			  }
				break;
				case 4:
				{
					displayTextLine(line5,"Job %d",job);
					GridSetDirection(GRID_DIR_NORTH);
					displayTextLine(line5,"Job %d After North",job);
					playSound(soundTada);
					sleep(2000);
					GridGoto(2,2);
					job++;
			  }
			  break;
				case 5:
				{
					displayTextLine(line5,"Job %d",job);
					GRID_TURN_SPEED_FAST = 30;
          GRID_TURN_SPEED_SLOW = -30;
					GridSetDirection(GRID_DIR_WEST);
					GRID_TURN_SPEED_FAST = 30;
          GRID_TURN_SPEED_SLOW = 0;
					displayTextLine(line5,"Job %d Turned West",job);
					playSound(soundTada);
					sleep(2000);
					GridGoto(0,2);
					job++;
			  }
			  break;
			  case 6:
			  {
			  	done = true;
			  }
				break;
			}
	  }

/*	  if(getDistanceValue(distLeft) > 100 && getDistanceValue(distRight) > 100)
	  {
			  updateMotorDriveTrain();
			  if(getDistanceValue(distLeft) > getDistanceValue(distRight))
			  	setMotorSpeeds(10,0);
			 else
			    setMotorSpeeds(0,10);
   }
   else
     stopAllMotors();

     displayTextLine(line5,"%d:%d:%d:%d ",getDistanceValue(distLeft),getDistanceValue(distRight),getDistanceSecondStrongest(distLeft),getDistanceSecondStrongest(distRight));*/
   /*
		displaySensorValues(line2, distLeft);
		displaySensorValues(line3, distRight);*/

	}
	displayText(line5,"done");
	playSound(soundPowerOff2);
}
