#pragma config(Sensor, port1,  bumper1,        sensorVexIQ_Touch)
#pragma config(Sensor, port3,  gyrosensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port4,  ledback,        sensorVexIQ_LED)
#pragma config(Sensor, port11, ledfront,       sensorVexIQ_LED)
#pragma config(Motor,  motor6,          ls,            tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor7,          e,             tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor9,          rs,            tmotorVexIQ, PIDControl, driveRight, encoder)
#pragma config(Motor,  motor12,         flipper,       tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* Grid Tracker Begin
*/
//TODO
// Documentation


/*Setup*/
#define GRID_WIDTH 2



#define GRID_THRESHHOLD_FOLLOWER 120
#define GRID_THRESHHOLD_DETECTOR 120
#define GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER  0
#define GRID_PORT_COLOR_SENSOR_LINE_DETECTOR  0
#define GRID_PORT_GYRO  gyrosensor
#define GRID_GYRO_THRESHOLD 1
#define GRID_MOTOR_RIGHT rs
#define GRID_MOTOR_LEFT ls
#define GRID_MOTOR_TRAVEL_PER_TURN_IN_MM 200

int GRID_SPEED_PRIMARY = 75;
int GRID_SPEED_SECONDARY = 25;
int GRID_TURN_SPEED_FAST = 50;
int GRID_TURN_SPEED_SLOW = 0;
bool GRID_DEBUG = true;


/*Local variables*/
int GridX = 0;
int GridY = 0;
int TargetX = 1;
int TargetY = 1;
int TargetDir = 0;
bool gridPause=true;

#define GRID_DIR_NORTH 0
#define GRID_DIR_EAST  270
#define GRID_DIR_SOUTH  180
#define GRID_DIR_WEST 90

int GridDirection = GRID_DIR_NORTH;
string sGridStatus = "";
bool bLineDetected = false;
//#define GRID_NO_MOVE

void GridStopAllMotors()
{
	stopMotor(GRID_MOTOR_RIGHT);
	stopMotor(GRID_MOTOR_LEFT);
}
void GridSetLocation(int x,int y)
{
	GridX = x;
	GridY = y;
}
void GridStatus(const char * s)
{
	sGridStatus = s;
	writeDebugStreamLine(sGridStatus);
}
int GridGetGyroDegrees()
{
	int Degrees = getGyroDegrees(GRID_PORT_GYRO);
	if(Degrees < 0)
	{
		while(Degrees < 0)
			Degrees += 360;
	}
	if(Degrees > 360)
	{
		while(Degrees > 360)
			Degrees -= 360;
	}
	return Degrees;
}
int GridGetDistance(int currentposition,int targetposition)
{
	int Distance;
	if(currentposition-targetposition < -180)
	{
		Distance=(currentposition-targetposition+180) * -1;
	}
	else
	{
		Distance=currentposition-targetposition;
	}
	return Distance;
}
void GridUpdateStatus()
{
	if(GRID_DEBUG)
	{
		displayTextLine(line1,"%d:%d %d:%d Dir:%d:%d:%d",GridX,GridY,TargetX,TargetY,GridGetGyroDegrees(),TargetDir,GridDirection);
		/*displayTextLine(line2,"%d:%d  %d:%d",getDistanceValue(distLeft),getDistanceValue(distRight),getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER),getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR));*/
		displayText(line3,sGridStatus);
	}
}
task Display()
{
	repeat (forever) {
		GridUpdateStatus();
		sleep(25);
	}

}
void GridInit()
{
	startTask(Display);
	clearDebugStream();
	GridStatus("GridInit");
	short count = 200;
	startGyroCalibration( GRID_PORT_GYRO, gyroCalibrateSamples64 );
	// delay so calibrate flag can be set internally to the gyro
	wait1Msec(100);


	/* Initialize Color Sensors while gyro is calibrating*/
	/*if(getColorMode(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER) != colorTypeGrayscale_Reflected)
	{
		setColorMode(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER, colorTypeGrayscale_Reflected);
		while(!getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER))
		{
			sleep(25);
		}
	}
	if(getColorMode(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) != colorTypeGrayscale_Reflected)
	{
		setColorMode(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR, colorTypeGrayscale_Reflected);
		while(!getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR))
		{
			sleep(25);
		}
	}*/
	// wait for calibration to finish or 2 seconds, whichever is longer
	while( getGyroCalibrationFlag(GRID_PORT_GYRO) && (count-- > 0) ) {
		char Status[64];
		sprintf(Status,"GridInit Testing Gyro %d",count);
		GridStatus(Status);
		wait1Msec(100);
	}
	// reset so this is 0 heading
	resetGyro(GRID_PORT_GYRO);
	GridStatus("GridInit Complete");
	sleep(1000);
}


void GridPause()
{
	GridStatus("Pause");
	gridPause = true;
}
void GridResume()
{
	GridStatus("GridResume");
	gridPause = false;
}
void GridGoto(int x,int y)
{
	GridStatus("Goto");
	TargetX=x;
	TargetY=y;
	GridResume();
}


void GridSetDirection(int Direction)
{
	GridStatus("GridSetDirection");
	updateMotorDriveTrain();
	TargetDir=Direction;

	while(abs(GridGetGyroDegrees()-Direction) > GRID_GYRO_THRESHOLD)
	{
		int Distance = GridGetDistance(GridGetGyroDegrees(),Direction);
		if(Distance > 0 && Distance <= 180)
		{
			//Right
#ifndef GRID_NO_MOVE
			setMotorSpeeds(GRID_TURN_SPEED_FAST,GRID_TURN_SPEED_SLOW);
#endif
		}
		else
		{
			//Left
#ifndef GRID_NO_MOVE
			setMotorSpeeds(GRID_TURN_SPEED_SLOW,GRID_TURN_SPEED_FAST);
#endif
		}
	}
#ifndef GRID_NO_MOVE
	GridStopAllMotors();
#endif
	GridDirection = Direction;
}

void GridTurnToLine()
{
	bool bFound = false;
	bool bOnLine = false;
	bool bReverse=true;
	updateMotorDriveTrain();
#ifndef	GRID_NO_MOVE
	setMotorSpeeds(GRID_TURN_SPEED_FAST, GRID_TURN_SPEED_FAST*-1);
#endif
	GridStatus("GridToLine Right");
	/*Find the right edge, when turning right wait until we cross the whole line*/
	int leftLimit = GridDirection+45;
	int rightLimit;
	if(GridDirection-45+360 >  360)
		rightLimit=GridDirection-45;
	else
		rightLimit=GridDirection-45+360;

	/*Get past zero if going to the right */
	if(rightLimit == 315)
	{
		while(GridGetGyroDegrees() < 340)
		{
			sleep(10);
		}
	}

	while(!bFound && !bReverse)
	{
		if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER) < GRID_THRESHHOLD_DETECTOR)
		{
			bOnLine = true;
		}
		else if(bOnLine)
		{
			bFound = true;
		}
		if(!bOnLine)
		{
			if(GridGetGyroDegrees() < rightLimit)
			{
#ifndef GRID_NO_MOVE
				GridStopAllMotors();
#endif
				bReverse=true;
			}
		}
	}
	if(!bFound)
	{
		GridStatus("GridToLine Left");
		bReverse=false;
#ifndef GRID_NO_MOVE
		setMotorSpeeds(GRID_TURN_SPEED_FAST * -1, GRID_TURN_SPEED_FAST);
#endif
		GridStatus("GridTurnToLine Left Restting to straight");
		while(abs(GridGetGyroDegrees()-GridDirection) > 3)
		{
			sleep(25);
		}

		/*Get past zero if going to the left */
		if(rightLimit == 45)
		{
			while(GridGetGyroDegrees() > 340)
			{
				sleep(10);
			}
		}
		GridStatus("GridTurnToLine Left");
		while(!bFound && !bReverse)
		{

			if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER) < GRID_THRESHHOLD_DETECTOR)
			{
				bFound = true;
			}
			if(GridGetGyroDegrees() > leftLimit)
			{
				bReverse=true;
			}
		}
	}
#ifndef GRID_NO_MOVE
	GridStopAllMotors();
#endif
	GridStatus("GridTurnToLine Done");
	if(!bFound)
	{
		playSound(soundCarAlarm4);
		sleep(2000);
	}
}

void GridProcess()
{
	updateMotorDriveTrain();

	if((GridX != TargetX || GridY != TargetY) && !gridPause)
	{
		if(GridY != TargetY)
		{
			if(GridY < TargetY)
			{
				if(GridDirection != GRID_DIR_NORTH)
				{
					GridStatus("Turning North");
					GridSetDirection(GRID_DIR_NORTH);
					GridTurnToLine();
				}
			}
			else
			{
				GridStatus("Turning South");
				if(GridDirection != GRID_DIR_SOUTH)
				{
					GridSetDirection(GRID_DIR_SOUTH);
					GridTurnToLine();
				}
			}
		}
		else if(GridX != TargetX)
		{
			if(GridX < TargetX)
			{
				GridStatus("Turning East");
				if(GridDirection != GRID_DIR_EAST)
				{
					GridSetDirection(GRID_DIR_EAST);
					GridTurnToLine();
				}
			}
			else
			{
				GridStatus("Turning West");
				if(GridDirection != GRID_DIR_WEST)
				{
					GridSetDirection(GRID_DIR_WEST);
					GridTurnToLine();
				}
			}
		}
		if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER) > GRID_THRESHHOLD_FOLLOWER)
		{
			GridStatus("Off the line");
#ifndef GRID_NO_MOVE
			setMotorSpeeds(GRID_SPEED_SECONDARY, GRID_SPEED_PRIMARY);
#endif
		}
		else
		{
			GridStatus("On the line");
#ifndef GRID_NO_MOVE
			setMotorSpeeds(GRID_SPEED_PRIMARY, GRID_SPEED_SECONDARY);
#endif
		}

		if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) < GRID_THRESHHOLD_DETECTOR && bLineDetected == false)
		{
			GridStatus("Line Detected");
			//playSound(soundTollBooth);
			if(GridDirection == GRID_DIR_NORTH)
				GridY++;
			else if(GridDirection == GRID_DIR_SOUTH)
				GridY--;
			else if(GridDirection == GRID_DIR_EAST)
				GridX++;
			else if(GridDirection == GRID_DIR_WEST)
				GridX--;

			bLineDetected = true;
		}
		if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) > GRID_THRESHHOLD_DETECTOR)
		{
			bLineDetected = false;
		}

	}
	else
	{
		/*Reached the target*/
		if(!gridPause)
		{
#ifndef GRID_NO_MOVE
			GridStopAllMotors();
#endif
			GridPause();
		}

	}
}

void GridFindLine(bool bFarSide)
{
	bool bFound = false;
	GridStatus("Finding Line");
#ifndef GRID_NO_MOVE
	setMotorSpeeds(GRID_SPEED_PRIMARY, GRID_SPEED_PRIMARY);
#endif
	while(!bFound)
	{
		if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) < GRID_THRESHHOLD_DETECTOR)
		{
			bFound = true;
		}
	}
	if(bFarSide)
	{
		bFound=false;
		while(!bFound)
		{
			if(getColorGrayscale(GRID_PORT_COLOR_SENSOR_LINE_DETECTOR) < GRID_THRESHHOLD_DETECTOR)
			{
				bFound = true;
			}
		}
	}
#ifndef GRID_NO_MOVE
	GridStopAllMotors();
#endif
}

void GridMoveForward(int mm)
{
	int Rotation = (((float)mm/(float)GRID_MOTOR_TRAVEL_PER_TURN_IN_MM) * 360);
	moveMotorTarget(GRID_MOTOR_RIGHT,Rotation,GRID_SPEED_PRIMARY);
	moveMotorTarget(GRID_MOTOR_LEFT,Rotation,GRID_SPEED_PRIMARY);
	waitUntilMotorStop(GRID_MOTOR_RIGHT);
	waitUntilMotorStop(GRID_MOTOR_LEFT);
}

void GridMoveBackward(int mm)
{
	int Rotation = (((float)mm/(float)GRID_MOTOR_TRAVEL_PER_TURN_IN_MM) * 360);
	moveMotorTarget(GRID_MOTOR_RIGHT,Rotation*-1,GRID_SPEED_PRIMARY);
	moveMotorTarget(GRID_MOTOR_LEFT,Rotation*-1,GRID_SPEED_PRIMARY);
	waitUntilMotorStop(GRID_MOTOR_RIGHT);
	waitUntilMotorStop(GRID_MOTOR_LEFT);
}

/*
* Grid Tracker End
*/



//breverse is the status of the controller's forward/reverse
//Fdown toggles directions
bool bReverse = true;


//built in function
//change to send controller's joystick values base on breverse
void myArcadeControl(TVexJoysticks verticalJoystick = ChA, TVexJoysticks horizontalJoystick = ChB, short threshold = 30)
{
	short nRightSideSpeed;
	short nLeftSideSpeed;

	updateMotorDriveTrain();

	if(abs(vexRT[verticalJoystick]) <= abs(threshold) && abs(vexRT[horizontalJoystick]) <= abs(threshold))
	{
		nRightSideSpeed = 0;
		nLeftSideSpeed 	= 0;
	}
	else
	{
		nRightSideSpeed = ((getJoystickValue(verticalJoystick) - getJoystickValue(horizontalJoystick))/2);
		nLeftSideSpeed = ((getJoystickValue(verticalJoystick) + getJoystickValue(horizontalJoystick))/2);

		if(nGlobalJoyScaledValue != nMaxJoyScaleValue)
		{
			nRightSideSpeed = nRightSideSpeed * (nGlobalJoyScaledValue / 100.0);
			nLeftSideSpeed 	= nLeftSideSpeed * (nGlobalJoyScaledValue / 100.0);
		}
	}
	displayTextLine(line3,"%d:%d",nRightSideSpeed,nLeftSideSpeed);
	//chage added
	if(bReverse)
		setMotorSpeeds(nLeftSideSpeed, nRightSideSpeed); //revese
	else
		setMotorSpeeds(nRightSideSpeed, nLeftSideSpeed); //forward
}

task main()
{
	bool bArcadeControl = false; //desides if the robot is going in tank control or arcade control
	bool bumper1Pressed = false; //when press move flipper
	bool btnFDownPressed = false; //when press toggles directions of the controller's forward/reverse
	bool btnFUpPressed = false; //when press toggles between tank control or arcade control
	bool bMotorOverlimit = false; //checks of motor is over current limit
	bool btnRDownPressed = false; //make it go forward
	bool btnLDownPressed = false;
	bool bumperdisabled = false;
	int StraightDirection = 0;
	GridInit();
	//program init
	setMotorCurrentLimit(flipper, 800);
	//display modes
	displayText(line1, "forward");
	displayText(line2, "tank");
  if(bReverse)
  {
  	displayText(line1, "reverse");
		setMotorReversed(ls, true);
		setMotorReversed(rs, false);
  }
	//checking forever
	//processing button presses
	repeat (forever) {
		//check if amps morter flipper is using and if is doing it over limit
		if(getMotorCurrent(flipper) > 600 && !bMotorOverlimit)
		{
			bMotorOverlimit = true;
			clearTimer(T1);
		}
		//set flipper amps using to 0 so you cn move it freely
		else if(getMotorCurrent(flipper) > 600 && bMotorOverlimit)
		{
			if(time1[T1] > 5000)
			{
				setMotorSpeed(flipper,0);
				setMotorBrakeMode(flipper, motorCoast);
			}
		}
		else
		{
			bMotorOverlimit = false;
		}

		if(!btnRDownPressed)
		{
			//tank control
			if(!bArcadeControl)
			{
				tankControl(ChD,ChA,10);
				if(bReverse)
				{
					setTouchLEDColor(ledback,colorGreen);
          setTouchLEDColor(ledfront, colorNone);
			  }
			  else
			  {
			  	setTouchLEDColor(ledfront, colorGreen);
          setTouchLEDColor(ledback, colorNone);
			  }



			}
			// arcade control
			else
			{
				myArcadeControl(ChD,ChC,10);
				if(bReverse)
				{
					setTouchLEDColor(ledback,colorRed);
          setTouchLEDColor(ledfront, colorNone);
			  }
			  else
			  {
			  	setTouchLEDColor(ledfront, colorRed);
          setTouchLEDColor(ledback, colorNone);
			  }
			}
		}
		//elevator
		//elevator direction based on button presses
		armControl(e, BtnRUp, BtnLUp, 100);


		//manual flipper controls
		if( vexRT[ BtnEDown ] == 1)
		{
			moveMotorTarget(flipper, 10, 50);
		}

		if( vexRT[ BtnEUp ] == 1)
		{
			moveMotorTarget(flipper, -10, 50);
		}

		if(!bumperdisabled)
		{
			//auto flipper based on bumper1 and bumper1pressed
			if(getBumperValue(bumper1) && bumper1Pressed == false)
			{

				setMotorTarget(flipper, -110, 20);
				bumper1Pressed = true;
			}

			if(!getBumperValue(bumper1) && bumper1Pressed)
			{
				setMotorTarget(flipper,0, 20);
				bumper1Pressed = false;
				// resetMotorEncoder(flipper);

			}

		}
		//toggle between forward/revers
		if(vexRT [BtnFDown]  == 1 && !btnFDownPressed)
		{
			btnFDownPressed = true;
			if(bReverse)
			{
				displayText(line1, "forward");
				setMotorReversed(ls, false);
				setMotorReversed(rs, true);
				bReverse=false;
			}
			else
			{
				displayText(line1, "reverse");
				setMotorReversed(ls, true);
				setMotorReversed(rs, false);
				bReverse=true;
			}

		}
		if(vexRT [BtnFDown]  == 0)
			btnFDownPressed = false;






		//toggle between arcade and tank controls
		if( vexRT[ BtnFUp ] == 1 && bArcadeControl && !btnFUpPressed)
		{
			btnFUpPressed = true;
			bArcadeControl = false;
			displayText(line2, "tank");
		}
		else if( vexRT[ BtnFUp ] == 1 && !bArcadeControl && !btnFUpPressed)
		{
			btnFUpPressed = true;
			bArcadeControl = true;
			displayText(line2, "arcade");
		}
		if( vexRT[ BtnFUp ] == 0)
			btnFUpPressed = false;

		//make it go forward
		if( vexRT[ BtnRDown ] == 1  && !btnRDownPressed)
		{
			btnRDownPressed = true;
			StraightDirection = getGyroHeading(gyrosensor);

			playSound(soundCarAlarm2);
			setMotor(rs,100);
			setMotor(ls,100);


		}
		else if( vexRT[ BtnRDown ] == 1)
		{
			int Distance = 0;
			if(abs(GridGetGyroDegrees()-StraightDirection) > GRID_GYRO_THRESHOLD)
	    {
    		Distance = GridGetDistance(GridGetGyroDegrees(),StraightDirection);
		    if(Distance > 0 && Distance <= 180)
		    {
		    	displayTextLine(line4,"Right %d",Distance);
			     //Right
		      if(bReverse)
		      {
		    	setMotor(rs,100);
			    setMotor(ls,90);
			    }
			    else
			    {
			    	setMotor(ls,100);
			    	setMotor(rs,90);
			    }
				}
		    else
		    {
		    	displayTextLine(line4,"Left %d",Distance);
		    	if(bReverse)
		    	{
			    //Left
		    	setMotor(rs,100);
			    setMotor(ls,90);
			  }
			  else
			  {
			  	setMotor(ls,100);
			  	setMotor(rs,90);

			  }
		    }
	    }
	    else
	    {
	    	displayTextLine(line4,"Straight %d",Distance);
		      setMotor(rs,100);
			    setMotor(ls,100);
		  }
		}
		else if( vexRT[ BtnRDown ] == 0 && btnRDownPressed)
		{
			btnRDownPressed = false;
			playSound(soundCarAlarm4);
			stopMotor(rs);
			stopMotor(ls);

		}


	//Disable Bumber
	/*if( vexRT[ BtnLDown ] == 1  && !btnLDownPressed)
	{
		btnLDownPressed = true;
		if(bumperdisabled)
			bumperdisabled = false;
		else
			bumperdisabled = true;

	}
	else if( vexRT[ BtnLDown ] == 0 && btnLDownPressed)
	{
		btnLDownPressed = false;

	}*/

}

}
