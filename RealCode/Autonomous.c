#pragma config(Sensor, port2,  centercolor,    sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port3,  gyrosensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port4,  ledback,        sensorVexIQ_LED)
#pragma config(Sensor, port5,  bumper1,        sensorVexIQ_Touch)
#pragma config(Sensor, port8,  rightcolor,     sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port11, ledfront,       sensorVexIQ_LED)
#pragma config(Motor,  motor6,          ls,            tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor7,          e,             tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor9,          rs,            tmotorVexIQ, PIDControl, driveRight, encoder)
#pragma config(Motor,  motor12,         flipper,       tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define GRID_WIDTH 4
#define GRID_LENGTH 8
#define GRID_THRESHHOLD_FOLLOWER 150
#define GRID_THRESHHOLD_DETECTOR 100
#define GRID_PORT_COLOR_SENSOR_LINE_FOLLOWER  centercolor
#define GRID_PORT_COLOR_SENSOR_LINE_DETECTOR  rightcolor
#define GRID_PORT_GYRO  gyrosensor
#define GRID_GYRO_THRESHOLD 2
#define GRID_MOTOR_RIGHT rs
#define GRID_MOTOR_LEFT ls
#define GRID_MOTOR_TRAVEL_PER_TURN_IN_MM 200
#define GRID_TURN_TO_LINE_DEGREES 10
int GRID_MOVE_AFTER_LINE = 110;

int GRID_SPEED_PRIMARY = 75;
int GRID_SPEED_SECONDARY = 50;
int GRID_TURN_SPEED_FAST = 50;
int GRID_TURN_SPEED_SLOW = 0;
int GRID_TURN_TO_LINE = 10;
bool GRID_DEBUG = true;
#include "GridTracker.c"

bool bDone = false;
task Elevator()
{
	bool bMotorOverlimit = false;
	setMotor(e,-100);
	while(!bDone)
	{
	//check if amps morter flipper is using and if is doing it over limit
		if(getMotorCurrent(e) > 600 && !bMotorOverlimit)
		{
			bMotorOverlimit = true;
			clearTimer(T1);
		}
		//set flipper amps using to 0 so you cn move it freely
		else if(getMotorCurrent(e) > 600 && bMotorOverlimit)
		{
			if(time1[T1] > 275)
			{
				setMotorSpeed(e,100);
				sleep(375);
			}
		}
		else
		{
			setMotorSpeed(e,-100);
			bMotorOverlimit = false;
		}
  }
  setMotor(e,0);
}
task CheckBumper()
{
		 bool bumper1Pressed=false;
		while(!bDone)
		{
				//auto flipper based on bumper1 and bumper1pressed
				if(getBumperValue(bumper1) && bumper1Pressed == false)
				{

					setMotorTarget(flipper, -110, 20);
					bumper1Pressed = true;
				}

				if(!getBumperValue(bumper1) && bumper1Pressed)
				{
					setMotorTarget(flipper,0, 20);
					bumper1Pressed = false;
					// resetMotorEncoder(flipper);

				}


	  }
}
task main()
{
	 bool bDone = false;
	 int job=1;

	 //set ups the grid tracter and sensers


   GridInit();
   sleep(1000);
   //go to frist line
   GridFindLine(true);

   //mke robot turn right
   GridSetDirection(GRID_DIR_EAST);
   //go backwards
   GridMoveBackward(300);
   //tell it were it is
   GridSetLocation(2,2);
   //set target to were he goes
 	 TargetX = 2;
	 TargetY = 2;


   while (!bDone) {
       GridProcess();

       if(gridPause)
       {
   	 		 switch(job)
   	  	 {
   	     	case 1:
   	     	{
      	     displayTextLine(line5,"Job %d",job);
						//make robot go in line to the bonus tray right side
					  	TargetX = 3;
						  TargetY = 2;
						  GridResume();
						   job++;
   	      	   break;
   	    	 }
   	    	 case 2:
   	    	 {
   	    	   //go to bounus tray right side and release it
      	       displayTextLine(line5,"Job %d",job);
						  GridSetDirection(GRID_DIR_NORTH);
						  GridMoveBackward(150);
						  GridTurnToLine();
						  GRID_MOVE_AFTER_LINE = 75;
						  GridGoto(3,8);

						   job++;
   	    	    break;
   	       }
   	       case 3:
   	       {
   	         displayTextLine(line5,"Job %d",job);
   	         //go to by left bonus tray
   	          GridMoveBackward(250);
   	          playSound(soundTada);
   	          GridSetDirection(GRID_DIR_WEST);
   	          GridMoveBackward(150);
   	          playSound(soundTada);
   	          GridSetLocation(3,7);
   	          GridGoto(1,7);
   	          job++;
   	          break;
   	       }
   	       case 4:
   	       {
   	         displayTextLine(line5,"Job %d",job);
   	         //move robot off the wall
   	          GridMoveBackward(150);
   	          //make robot face bouns tray
   	         GridSetDirection(GRID_DIR_NORTH);
   	         // release bouns tray
   	          GridMoveForward(50);

   	         job++;
   	          break;
   	       }
   	       case 5:
   	       {
   	         displayTextLine(line5,"Job %d",job);
   	         GridMoveBackward(375);
   	         GridSetDirection(GRID_DIR_WEST);

   	         startTask(Elevator);
   	         startTask(CheckBumper);

   	         GRID_SPEED_PRIMARY = 10;
   	        GridMoveBackward(400);
   	        GRID_TURN_SPEED_FAST = 50;
   	        GRID_TURN_SPEED_SLOW = -50;
   	        GridSetDirection(GRID_DIR_EAST);
   	        //GridTurnToLine();
   	        GridSetLocation(3,7);
   	        GridGoto(3,8);
   	        //GridMoveForward(120);
   	         job++;
   	     }
   	    	 case 6:
   	    	 {
   	    	   displayTextLine(line5,"Job %d",job);
   	    	   GridSetDirection(GRID_DIR_EAST);
   	    	   GridMoveForward(120);
   	    	   sleep(5500);
   	    	   bDone = true;
   	    	     break;
   	       }

   	  	}
   	  }
   }
   playSound(soundTada);


}
