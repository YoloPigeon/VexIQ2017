#pragma config(Sensor, port5,  bumper1,        sensorVexIQ_Touch)
#pragma config(Motor,  motor2,          rs,            tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor6,          ls,            tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor7,          e,             tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor12,         flipper,       tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//breverse is the status of the controller's forward/reverse
//Fdown toggles directions
bool bReverse = false;


//built in function
//change to send controller's joystick values base on breverse
void myArcadeControl(TVexJoysticks verticalJoystick = ChA, TVexJoysticks horizontalJoystick = ChB, short threshold = 10)
{
	short nRightSideSpeed;
	short nLeftSideSpeed;

	updateMotorDriveTrain();

	if(abs(vexRT[verticalJoystick]) <= abs(threshold) && abs(vexRT[horizontalJoystick]) <= abs(threshold))
	{
		nRightSideSpeed = 0;
		nLeftSideSpeed 	= 0;
	}
	else
	{
	 	nRightSideSpeed = ((getJoystickValue(verticalJoystick) - getJoystickValue(horizontalJoystick))/2);
		nLeftSideSpeed = ((getJoystickValue(verticalJoystick) + getJoystickValue(horizontalJoystick))/2);

		if(nGlobalJoyScaledValue != nMaxJoyScaleValue)
		{
			nRightSideSpeed = nRightSideSpeed * (nGlobalJoyScaledValue / 100.0);
			nLeftSideSpeed 	= nLeftSideSpeed * (nGlobalJoyScaledValue / 100.0);
		}
	}
	//chage added
	if(bReverse)
		setMotorSpeeds(nLeftSideSpeed, nRightSideSpeed); //revese
	else
		setMotorSpeeds(nRightSideSpeed, nLeftSideSpeed); //forward
}

task main()
{
	bool bArcadeControl = false; //desides if the robot is going in tank control or arcade control
  bool bumper1Pressed = false; //when press move flipper
  bool btnFDownPressed = false; //when press toggles directions of the controller's forward/reverse
  bool btnFUpPressed = false; //when press toggles between tank control or arcade control
  bool bMotorOverlimit = false; //checks of motor is over current limit
  bool btnRDownPressed = false; //make it go forward
  //program init
  setMotorCurrentLimit(flipper, 800);
  //display modes
  displayText(line1, "forward");
  displayText(line2, "tank");

  //checking forever
  //processing button presses
  repeat (forever) {
  	//check if amps morter flipper is using and if is doing it over limit
		 if(getMotorCurrent(flipper) > 600 && !bMotorOverlimit)
	   {
	     bMotorOverlimit = true;
	     clearTimer(T1);
	   }
	   //set flipper amps using to 0 so you cn move it freely
	   else if(getMotorCurrent(flipper) > 600 && bMotorOverlimit)
	   {
	     if(time1[T1] > 5000)
	     {
	       setMotorSpeed(flipper,0);
	       setMotorBrakeMode(flipper, motorCoast);
	     }
	   }
	   else
	   {
	   	 bMotorOverlimit = false;
	   }

  if(!btnRDownPressed)
  {
  	//tank control
  	if(!bArcadeControl)
	  	tankControl(ChD,ChA,10);
	 // arcade control
	 else
	   myArcadeControl(ChD,ChC,10);
}
	 //elevator
	 //elevator direction based on button presses
	  armControl(e, BtnRUp, BtnLUp, 100);


    //manual flipper controls
    if( vexRT[ BtnEDown ] == 1)
	  {
	  	moveMotorTarget(flipper, 10, 50);
	  }

	  if( vexRT[ BtnEUp ] == 1)
	  {
	  	moveMotorTarget(flipper, -10, 50);
	  }


	  //auto flipper based on bumper1 and bumper1pressed
	  if(getBumperValue(bumper1) && bumper1Pressed == false)
	   {

	     setMotorTarget(flipper, -130, 20);
	     bumper1Pressed = true;
	   }

	  if(!getBumperValue(bumper1) && bumper1Pressed)
	   {
	     setMotorTarget(flipper,0, 20);
	     bumper1Pressed = false;
	    // resetMotorEncoder(flipper);

	   }
	   //toggle between forward/revers
	   if(vexRT [BtnFDown]  == 1 && !btnFDownPressed)
	   {
	     btnFDownPressed = true;
	     if(bReverse)
	     {
	         displayText(line1, "forward");
	       	 setMotorReversed(ls, false);
			     setMotorReversed(rs, true);
			     bReverse=false;
	     }
	     else
	     {
	         displayText(line1, "reverse");
	       	 setMotorReversed(ls, true);
			     setMotorReversed(rs, false);
			     bReverse=true;
	     }

	   }
	   if(vexRT [BtnFDown]  == 0)
	     btnFDownPressed = false;






	     //toggle between arcade and tank controls
  	if( vexRT[ BtnFUp ] == 1 && bArcadeControl && !btnFUpPressed)
		{
			btnFUpPressed = true;
			bArcadeControl = false;
			displayText(line2, "tank");
		}
		else if( vexRT[ BtnFUp ] == 1 && !bArcadeControl && !btnFUpPressed)
		{
			btnFUpPressed = true;
			bArcadeControl = true;
			displayText(line2, "arcade");
   	}
   	if( vexRT[ BtnFUp ] == 0)
   		btnFUpPressed = false;

   		//make it go forward
	if( vexRT[ BtnRDown ] == 1  && !btnRDownPressed)
		{
			btnRDownPressed = true;
			playSound(soundCarAlarm2);
			setMotor(rs,100);
			setMotor(ls,100);


		}
		else if( vexRT[ BtnRDown ] == 0 && btnRDownPressed)
		{
			btnRDownPressed = false;
			playSound(soundCarAlarm4);
      stopMotor(rs);
      stopMotor(ls);

   	}

  }


}

